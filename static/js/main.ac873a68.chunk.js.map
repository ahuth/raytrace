{"version":3,"sources":["utils/vector.js","scene/camera.js","scene/lights.js","utils/sphere.js","scene/objects.js","utils/ray.js","components/app.jsx","utils/render.js","index.js"],"names":["UP","create","WHITE","ZERO","x","y","z","dot","a","b","cross","scale","factor","unitVector","Math","sqrt","length","add","add3","c","subtract","scene_camera","point","Vector","fieldOfView","vector","lights","_ref","color","specular","lambert","ambient","radius","intersection","sphere","ray","eyeToCenter","vectorLength","toCenterOfSphereLength","discriminant","objects","Sphere","origin","trace","scene","depth","_intersectScene","intersectScene","distance","object","Infinity","intersectionPoint","normal","objectColor","rayColor","lambertAmount","i","lightPoint","isLightVisible","contribution","reflectedRay","temp","reflectedColor","min","surface","closest","light","App","canvasRef","React","createRef","playing","planet1","planet2","handlePlay","_this","tick","handleStop","sin","cos","nextPixelData","height","width","pixelData","camera","eyeVector","facingRight","facingUp","fovRadians","PI","heightWidthRatio","halfWidth","tan","halfHeight","pixelWidth","pixelHeight","xComp","yComp","Ray","index","data","render","ctx","putImageData","setTimeout","this","current","getContext","getImageData","react_default","createElement","style","styles","container","ref","canvas","onClick","Component","alignItems","display","flexDirection","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.ac873a68.chunk.js","sourcesContent":["export const UP = create(0, 1, 0);\nexport const WHITE = create(255, 255, 255);\nexport const ZERO = create(0, 0, 0);\n\nexport function create(x, y, z) {\n  return { x, y, z };\n}\n\n// Return the Euclidean norm (AKA length) of a vector.\n// See https://en.wikipedia.org/wiki/Euclidean_vector#Length\nexport function length(a) {\n  return Math.sqrt(dot(a, a));\n}\n\n// Return the dot product of two vectors.\n// See https://en.wikipedia.org/wiki/Dot_product\nexport function dot(a, b) {\n  return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);\n}\n\n// Return the cross product of two vectors.\n// See https://en.wikipedia.org/wiki/Cross_product\nexport function cross(a, b) {\n  return create(\n    (a.y * b.z) - (a.z * b.y),\n    (a.z * b.x) - (a.x * b.z),\n    (a.x * b.y) - (a.y * b.x),\n  );\n}\n\n// Elongate or shrink a vector by `factor`.\nexport function scale(a, factor) {\n  return create(\n    a.x * factor,\n    a.y * factor,\n    a.z * factor,\n  );\n}\n\n// Return a new vector with magnitude (or length) of 1.\nexport function unitVector(a) {\n  return scale(a, 1 / length(a));\n}\n\n// Return a new vector by adding together two vectors.\nexport function add(a, b) {\n  return create(\n    a.x + b.x,\n    a.y + b.y,\n    a.z + b.z,\n  );\n}\n\n// Return a new vector by adding together three vectors.\nexport function add3(a, b, c) {\n  return create(\n    a.x + b.x + c.x,\n    a.y + b.y + c.y,\n    a.z + b.z + c.z,\n  );\n}\n\n// Return a new vector by subtracting one from another.\nexport function subtract(a, b) {\n  return create(\n    a.x - b.x,\n    a.y - b.y,\n    a.z - b.z,\n  );\n}\n\n// Given a vector `a` and a `normal`, which is the angle at which\n// the vector hits a surface, return a new vector which is reflected off of\n// that surface.\nexport function reflectThrough(a, normal) {\n  const temp = scale(normal, dot(a, normal));\n  return subtract(scale(temp, 2), a);\n}\n","import * as Vector from '../utils/vector.js';\n\nexport default {\n  point: Vector.create(0, 1.8, 10),\n  fieldOfView: 45,\n  vector: Vector.create(0, 3, 0),\n};\n","import * as Vector from '../utils/vector.js';\n\nexport default [\n  Vector.create(-30, -10, 20),\n];\n","import * as Vector from './vector';\n\nexport function create({ point, color, specular, lambert, ambient, radius }) {\n  return { point, color, specular, lambert, ambient, radius };\n}\n\n// A normal is a vector radiating outward from a point on a sphere's surface, perpendicular to the\n// surface. See https://en.wikipedia.org/wiki/Normal_(geometry).\nexport function normal(sphere, point) {\n  return Vector.unitVector(Vector.subtract(point, sphere.point));\n}\n\n// Get the distance between a sphere and a ray.\nexport function intersection(sphere, ray) {\n  // Imagine a triangle with the following sides:\n  // - Camera point to center of the sphere\n  // - The ray's vector\n  // - Right angle between the other two\n  const eyeToCenter = Vector.subtract(sphere.point, ray.point);\n  const vectorLength = Vector.dot(eyeToCenter, ray.vector);\n  const toCenterOfSphereLength = Vector.dot(eyeToCenter, eyeToCenter);\n\n  // Not exactly sure what a disciminant is, but see https://en.wikipedia.org/wiki/Discriminant.\n  // Has something to do with the segment from the right angle of the triangle to a point on the\n  // vector's line that also intersects the sphere.\n  const discriminant = (sphere.radius * sphere.radius) - toCenterOfSphereLength + (vectorLength * vectorLength);\n\n  // If the descriminant is negative, the sphere has **_not_** been hit by the ray.\n  if (discriminant < 0) {\n    return;\n  }\n\n  // Return the distance from the camera to the sphere.\n  return vectorLength - Math.sqrt(discriminant);\n}\n","import * as Sphere from '../utils/sphere.js';\nimport * as Vector from '../utils/vector.js';\n\nexport default [\n  Sphere.create({\n    point: Vector.create(0, 3.5, -3),\n    color: Vector.create(155, 200, 155),\n    specular: 0.2,\n    lambert: 0.7,\n    ambient: 0.1,\n    radius: 3,\n  }),\n  Sphere.create({\n    point: Vector.create(-4, 2, -1),\n    color: Vector.create(155, 155, 155),\n    specular: 0.1,\n    lambert: 0.9,\n    ambient: 0.0,\n    radius: 0.2,\n  }),\n  Sphere.create({\n    point: Vector.create(-4, 3, -1),\n    color: Vector.create(255, 255, 255),\n    specular: 0.2,\n    lambert: 0.7,\n    ambient: 0.1,\n    radius: 0.1,\n  }),\n];\n","import * as Sphere from './sphere.js';\nimport * as Vector from './vector.js';\n\nexport function create(origin, vector) {\n  return {\n    point: origin,\n    vector,\n  };\n}\n\n// Given a ray, shoot it through the scene until it hits an object and return that object's color.\nexport function trace(ray, scene, depth) {\n  // Limit the amount of bouncing around (and therefore recursion) that we'll do.\n  if (depth > 3) { return; }\n\n  // Find what this ray hits and how far it travelled to do so.\n  const { distance, object } = intersectScene(ray, scene);\n\n  if (distance === Infinity) {\n    return Vector.WHITE;\n  }\n\n  // Find the point this Ray intersects by taking the direction the ray is going and making it as\n  // long as the distance from the intersection check.\n  const intersectionPoint = Vector.add(ray.point, Vector.scale(ray.vector, distance));\n\n  // Return the color the ray should be after interacting with objects in the scene.\n  return surface(\n    ray,\n    scene,\n    object,\n    intersectionPoint,\n    Sphere.normal(object, intersectionPoint),\n    depth,\n  );\n}\n\n// Given a ray, find the closest thing it hits in the scene.\nfunction intersectScene(ray, scene) {\n  let closest = {\n    distance: Infinity,\n    object: null,\n  };\n\n  for (let i = 0; i < scene.objects.length; i++) {\n    const object = scene.objects[i];\n    const distance = Sphere.intersection(object, ray);\n\n    if (distance != null && distance < closest.distance) {\n      closest = { distance, object };\n    }\n  }\n\n  return closest;\n}\n\n\n// Given that we a ray has hit an object, determine what color the ray acquires from the\n// interaction.\nfunction surface(ray, scene, object, intersectionPoint, normal, depth) {\n  const objectColor = object.color;\n  let rayColor = Vector.ZERO;\n  let lambertAmount = 0;\n\n  // Lambert shading.\n  // See http://en.wikipedia.org/wiki/Lambertian_reflectance\n  if (object.lambert) {\n    for (let i = 0; i < scene.lights.length; i++) {\n      const lightPoint = scene.lights[i];\n\n      // Can we even see the light?\n      if (!isLightVisible(intersectionPoint, scene, lightPoint)) { continue; }\n\n      // Calculate lambertian reflectance.\n      const contribution = Vector.dot(\n        Vector.unitVector(Vector.subtract(lightPoint, intersectionPoint)),\n        normal,\n      );\n\n      if (contribution > 0) {\n        lambertAmount += contribution;\n      }\n    }\n  }\n\n  // Specular reflection.\n  // See https://en.wikipedia.org/wiki/Specular_reflection\n  if (object.specular) {\n    // Basically the same process as 'render', except from the standpoint of a point on an object.\n    const reflectedRay = create(\n      intersectionPoint,\n      Vector.reflectThrough(ray.vector, normal),\n    );\n\n    const reflectedColor = trace(reflectedRay, scene, depth + 1);\n\n    if (reflectedColor) {\n      rayColor = Vector.add(rayColor, Vector.scale(reflectedColor, object.specular));\n    }\n  }\n\n  // Ensure lambert never \"blows out\" the lighting of an object, even if it bounces between lots of\n  // objects and lights.\n  lambertAmount = Math.min(1, lambertAmount);\n\n  // Ambient light shines bright regardless of whether a light is visible or not.\n  return Vector.add3(\n    rayColor,\n    Vector.scale(objectColor, lambertAmount * object.lambert),\n    Vector.scale(objectColor, object.ambient),\n  );\n}\n\n// Check whether a light is visible from some point on the surface of something.\n// Note that there might be an intersection here, which is tricky - but if it's\n// tiny, it's actually an intersection with the object we're trying to decide\n// the surface of. That's why we check for `> -0.005` at the end.\n//\n// This is the part that makes objects cast shadows on each other: from here\n// we'd check to see if the area in a shadowy spot can 'see' a light, and when\n// this returns `false`, we make the area shadowy.\nfunction isLightVisible(point, scene, light) {\n  const { distance } = intersectScene(\n    create(\n      point,\n      Vector.unitVector(Vector.subtract(point, light))),\n    scene,\n  );\n\n  return distance > -0.005;\n}\n","import React from 'react';\nimport * as scene from '../scene';\nimport render from '../utils/render.js';\n\nexport default class App extends React.Component {\n  canvasRef = React.createRef();\n  playing = false;\n  planet1 = 0;\n  planet2 = 0;\n\n  componentDidMount() {\n    this.ctx = this.canvasRef.current.getContext('2d');\n    this.pixelData = this.ctx.getImageData(0, 0, 320, 240);\n    this.tick();\n  }\n\n  handlePlay = () => {\n    this.playing = true;\n    this.tick();\n  }\n\n  handleStop = () => {\n    this.playing = false;\n  }\n\n  tick = () => {\n    // Straight-line distance covered. Note that planet2 orbits a bit faster.\n    this.planet1 += 0.1;\n    this.planet2 += 0.2;\n\n    // Convet straight-line distance to orbital positions with some trigonometry.\n    scene.objects[1].point.x = Math.sin(this.planet1) * 3.5;\n    scene.objects[1].point.z = -3 + (Math.cos(this.planet1) * 3.5);\n\n    scene.objects[2].point.x = Math.sin(this.planet2) * 4;\n    scene.objects[2].point.z = -3 + (Math.cos(this.planet2) * 4);\n\n    // Render everything.\n    const nextPixelData = render(scene, 240, 320, this.pixelData);\n    this.ctx.putImageData(nextPixelData, 0, 0);\n\n    // Move the planets and render again.\n    if (this.playing) {\n      setTimeout(this.tick, 10);\n    }\n  }\n\n  render() {\n    return (\n      <div style={styles.container}>\n        <canvas\n          height={240}\n          ref={this.canvasRef}\n          style={styles.canvas}\n          width={320}\n        />\n        <div>\n          <button onClick={this.handlePlay}>Play</button>\n          <button onClick={this.handleStop}>Stop</button>\n        </div>\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  canvas: {\n    height: 480,\n    width: 640,\n  },\n  container: {\n    alignItems: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n  },\n};\n","import * as Ray from './ray.js';\nimport * as Vector from './vector.js';\n\n// For each pixel of our canvas, bounce a ay from the eye through the scene, determining if any\n// objects or lights are encountered.\nexport default function render(scene, height, width, pixelData) {\n  const { camera } = scene;\n\n  // Vector pointing in the direction the camera is pointing.\n  const eyeVector = Vector.unitVector(Vector.subtract(camera.vector, camera.point));\n\n  // Vectors rotated up and right from the direction the camera is pointing. Recall that the cross\n  // product returns a new vector perpendicular to plain formed by two vectors.\n  const facingRight = Vector.unitVector(Vector.cross(eyeVector, Vector.UP));\n  const facingUp = Vector.unitVector(Vector.cross(facingRight, eyeVector));\n\n  const fovRadians = Math.PI * (camera.fieldOfView / 2) / 180;\n  const heightWidthRatio = height / width;\n  const halfWidth = Math.tan(fovRadians);\n  const halfHeight = heightWidthRatio * halfWidth;\n  const cameraWidth = halfWidth * 2;\n  const cameraHeight = halfHeight * 2;\n  const pixelWidth = cameraWidth / (width - 1);\n  const pixelHeight = cameraHeight / (height - 1);\n\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      // Turn the ray `x` and `y` pixel values into values between -1 and 1, and use those values\n      // to scale the right and up vectors, so tht we can skew the eye vector in each necessary\n      // direction.\n      const xComp = Vector.scale(facingRight, x * pixelWidth - halfWidth);\n      const yComp = Vector.scale(facingUp, y * pixelHeight - halfHeight);\n\n      const ray = Ray.create(\n        camera.point,\n        Vector.unitVector(Vector.add3(eyeVector, xComp, yComp)),\n      );\n\n      const color = Ray.trace(ray, scene, 0);\n      const index = (x * 4) + (y * width * 4);\n\n      // Directly modify the pixel data of our canvas.\n      pixelData.data[index + 0] = color.x;\n      pixelData.data[index + 1] = color.y;\n      pixelData.data[index + 2] = color.z;\n      pixelData.data[index + 3] = 255;\n    }\n  }\n\n  // Return the generated pixel values.\n  return pixelData;\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/app.jsx';\n\nReactDOM.render(React.createElement(App), document.getElementById('root'));\n"],"sourceRoot":""}